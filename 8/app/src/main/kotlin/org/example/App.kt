/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import java.io.File

const val EMPTY_TILE = '.'
const val ANTINODE_TILE = '#'

fun main() {
    val file = File("app/src/main/resources/listExo.txt")
    val map = file.readLines().map { it.toCharArray() }.toTypedArray()

    val maxY = map.size - 1
    val maxX = map.first().size - 1

    println("maxs : $maxY / $maxX")

    val antennas = hashMapOf<Position, Char>()
    val antinodes = hashSetOf<Position>()

    for (y in 0..maxY) {
        for (x in 0..maxX) {
            val current = map[y][x]
            if (current != EMPTY_TILE) {
                antennas[Position(y, x)] = current
            }
        }
    }

    val antennasAsAntinodes = hashSetOf<Position>()
    antennas.forEach { (position, antenna) ->
        val otherAntennas = antennas.filter { (otherPosition, otherAntenna) ->
            position != otherPosition && otherAntenna == antenna
        }
        otherAntennas.forEach { (otherPosition, _) -> //generate antinodes
            antennasAsAntinodes.add(position)
            val distance = otherPosition - position
            var antinodePosition = otherPosition + distance
            while (antinodePosition.isIn(maxY, maxX)) {
                antinodes.add(antinodePosition)
                println("antenna : $position /// other antenna : $otherPosition /// distnace : $distance /// pos : $antinodePosition")
                antinodePosition += distance
            }
        }
    }

    val antinodeMap = map.map { it.toMutableList() }.toMutableList()
    antinodes.forEach { (y, x) ->
        antennasAsAntinodes.remove(Position(y, x)) // A single cell can only be one antinode, avoid count twice
        antinodeMap[y][x] = ANTINODE_TILE
    }

    antinodeMap.forEach { println(it.joinToString("")) }
    println(antinodes.count() + antennasAsAntinodes.count())
}

data class Position(val y: Int, val x: Int) {
    operator fun minus(position: Position): Position {
        val newY = if (position.y < 0) y + position.y else y - position.y
        val newX = if (position.x < 0) x + position.x else x - position.x
        return Position(newY, newX)
    }

    operator fun plus(position: Position): Position {
        return Position(position.y + y, position.x + x)
    }

    fun isIn(maxY: Int, maxX: Int): Boolean {
        return y in 0..maxY && x in 0..maxX
    }
}